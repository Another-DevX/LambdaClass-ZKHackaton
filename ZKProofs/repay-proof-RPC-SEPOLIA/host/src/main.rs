// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::{Chain, Context, Result};
use ethers_providers::Caller;
use methods::{LIQUIDITY_LOCK_GUEST_ELF, LIQUIDITY_LOCK_GUEST_ID};
use proof_core::core::{LiquidityLookResult, Stake, U256};

use alloy_primitives::{address, Address};
use alloy_sol_types::{sol, SolCall, SolValue};
use risc0_steel::{
    config::{ChainSpec, ETH_SEPOLIA_CHAIN_SPEC},
    ethereum::EthEvmEnv,
    Contract, EvmBlockHeader,
};
use risc0_zkvm::{default_executor, default_prover, ExecutorEnv};
// use revm::primitives::SpecId;
use tracing_subscriber::EnvFilter;

use clap::Parser;

#[derive(Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// URL of the RPC endpoint
    #[arg(short, long, env = "RPC_URL")]
    rpc_url: String,

    // #[clap(long)]
    // account: Address,

    // #[arg(long)]
    // lend_id: u64,
}

sol! {
    interface IYTP {
        function getLend(address user, uint lendId) public  view  returns (uint);
    }
}

/// Address of the deployed contract to call the function on (USDT contract on Sepolia).
const CONTRACT: Address = address!("E501F32748Ea5c70f2FA617db70EB3Aa063FA16f");
/// Address of the caller.
const CALLER: Address = address!("f08A50178dfcDe18524640EA6618a1f965821715");

fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let args = Args::parse();


    let CALL: IYTP::getLendCall = IYTP::getLendCall {
        user:  address!("aA8E23Fb1079EA71e0a56F48a2aA51851D8433D0"),
        lendId: U256::from(1),
    };

    let mut env = EthEvmEnv::from_rpc(&args.rpc_url, None)?;
    env = env.with_chain_spec(&ETH_SEPOLIA_CHAIN_SPEC);

    let commitment = env.block_commitment();

    let mut contract = Contract::preflight(CONTRACT, &mut env);

    let returns = contract.call_builder(&CALL).from(CALLER).call()?;
    println!(
        "For block {} `{}` returns: {}",
        env.header().number(),
        IYTP::getLendCall::SIGNATURE,
        returns._0
    );

    println!("Committing the block commitment to the zkVM input.");
    let input = env.into_input()?;

    println!("Running the guest with the constructed input:");
    let session_info = {
        let env = ExecutorEnv::builder()
            .write(&input)?
            .write(&address!("aA8E23Fb1079EA71e0a56F48a2aA51851D8433D0"))?
            .write(&U256::from(1))?
            .build()
            .context("Failed to build exec env")?;
        let exec = default_executor();
        exec.execute(env, LIQUIDITY_LOCK_GUEST_ELF)
            .context("failed to run executor")?
    };

    let bytes = session_info.journal.as_ref();
    assert!(bytes.starts_with(&commitment.abi_encode()));
    Ok(())
}
