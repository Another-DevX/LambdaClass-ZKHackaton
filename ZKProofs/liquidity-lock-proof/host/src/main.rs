// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use proof_core::core::{ LiquidityLookResult, Stake, U256};
use methods::{LIQUIDITY_LOCK_GUEST_ELF, LIQUIDITY_LOCK_GUEST_ID};
use anyhow::{Chain, Context, Result};

use risc0_zkvm::{default_executor,default_prover, ExecutorEnv};
use alloy_sol_types::{sol, SolCall, SolValue};
use alloy_primitives::{address, Address};
use risc0_steel::{config::{ChainSpec, EIP1559_CONSTANTS_DEFAULT} ,ethereum::EthEvmEnv, Contract, EvmBlockHeader };
use revm::primitives::SpecId;
use tracing_subscriber::EnvFilter;

use clap::Parser;


#[derive(Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// URL of the RPC endpoint
    #[arg(short, long, env = "RPC_URL")]
    rpc_url: String,
    
    #[clap(long)]
    account: Address,

    #[arg(long)]
    lend_id: u64,
}



sol! {
    interface IYTP {
        function getLend(address user, uint256 lendId) public  view  returns (uint256 value);
    }
}

/// Address of the deployed contract to call the function on (USDT contract on Sepolia).
const CONTRACT: Address = address!("6765E325c59376B706b7fFc5bc12664580438FBB");
/// Address of the caller.
const CALLER: Address = address!("f08A50178dfcDe18524640EA6618a1f965821715");



fn main() -> Result<()> {
    tracing_subscriber::fmt()
    .with_env_filter(EnvFilter::from_default_env())
    .init();

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    let args = Args::parse();


    let mut ZK_SYNC_SPEC: ChainSpec =  ChainSpec::new_single(0x12c,SpecId::LATEST  ,EIP1559_CONSTANTS_DEFAULT);
  
    let CALL: IYTP::getLendCall = IYTP::getLendCall {
        user: address!("9737100D2F42a196DE56ED0d1f6fF598a250E7E4"),
        lendId: U256::from(1),
    };
    
    // Create an EVM environment from an RPC endpoint and a block number. If no block number is
    // provided, the latest block is used.
    let mut env = EthEvmEnv::from_rpc(&args.rpc_url, None)?;
    //  The `with_chain_spec` method is used to specify the chain configuration.
    env = env.with_chain_spec(&ZK_SYNC_SPEC);

    let commitment = env.block_commitment();



    let mut contract = Contract::preflight(CONTRACT, &mut env);

    let returns = contract.call_builder(&CALL).from(CALLER).call()?;
    println!(
        "For block {} `{}` returns: {}",
        env.header().number(),
        IYTP::getLendCall::SIGNATURE,
        returns.value
    );

    let input = env.into_input()?;

    println!("Running the guest with the constructed input:");
    let session_info = {
        let env = ExecutorEnv::builder()
            .write(&input)?
            .write(&args.account)?
            .write(&args.lend_id)?
            .build()
            .context("Failed to build exec env")?;
        let exec = default_executor();
        exec.execute(env, LIQUIDITY_LOCK_GUEST_ELF)
            .context("failed to run executor")?
    };

    // The commitment in the journal should match.
    let bytes = session_info.journal.as_ref();
    assert!(bytes.starts_with(&commitment.abi_encode()));
    Ok(())


    // let amount = U256::from(10);
    // let address = Address::random();
    // let input = Stake { amount, address };

    // let env = ExecutorEnv::builder()
    //     .write(&input)
    //     .unwrap()
    //     .build()
    //     .unwrap();

    // let prover = default_prover();

    // let prove_info = prover.prove(env, LIQUIDITY_LOCK_GUEST_ELF).unwrap();

    // let receipt = prove_info.receipt;

    // let _output: LiquidityLookResult = receipt.journal.decode().unwrap();

    // println!("{:?}", _output);

    // receipt.verify(LIQUIDITY_LOCK_GUEST_ID).unwrap();
}
